# 简答题
## 简答一、说出以下执行结果，并且解释为什么
执行结果为10，因为i的定义用var 会进行变量提升，当循环结束后，i的值为10，所以a[6]()执行结果为10
## 简答二、请说出最终执行结果，并解释为什么
执行结果为 tmp is not defined, 因为if代码块中的tmp是在console后面定义的，所以先console，会报错
## 简答三、结合Es6找到数组中最小值
Math.min(...arr)
## 简答四、详细说var、let、const三种声明变量方式的差异
- var声明的变量会被挂载到全局Global，存在变量提升，并且在函数体执行完成并不存在引用的时候最后被回收释放
- const 块级作用域，只能在块级的内部进行访问，被挂载在scope中，const通常去声明常量，const声明对象后，不能去更改对象的引用地址
- let 块级作用域，只能在块级的内部进行访问，被挂载在scope中，let通常去声明变量，声明对象后，可以去改变对象的引用地址
## 简答五、说出代码执行结果，并解释为什么
执行结果为20，因为fn内部的箭头函数指向的是当前调用,所以函数体内部的this指向obj对象，this.name就位obj里面的内部，20
## 简答六、简述Symbol对象的用途
Symbol是一种全新的原始数据类型，在es2015之前，对象的键值都是字符串，全局的对象添加属性容易出现命名冲突
- Symbol的特点是独一无二，通过Symbol(创建的每个值都是独一无二的，所以我们可以将Symbol作为对象的属性值
- 因为使用传统的for...in 是拿不到Symbol定义的属性值，所以可以借助此特性模拟对象的私有成员，如需获取可以通过Object.getOwnProperty(obj)获取全是Symbol的属性名对象
## 简答七、谈谈深拷贝和浅拷贝
- js中基本数据类型存放在栈中，而引用数据类型存放在堆中，变量时间上是一个存放在栈内存中的地址，这个指针指向堆内存中的地址
- 浅拷贝只是拷贝了变量，并没有改变他的内存地址，重新赋值会改变源对象
- 深拷贝是拷贝了地址和内存，重新赋值不会改变源对象
## 简答八、简书TypeScript 和 JavaScript之间的关系
## 简答九、TypeScript的优缺点
## 简答十、描述引用计数的工作原理和有缺低昂
## 简答十一、描述标记整理算法的工作流程
## 简答十二、描述V8中新生代存储区垃圾回收的流程
## 简答十三、描述增量标记算法在何时使用及工作原理


# 学习笔记
## [ECMAScript](https://www.jianshu.com/p/44376bfc8208)
## [TypeScript语言](https://www.jianshu.com/p/c54c9b223a7c)
## [JS性能优化——JavaScript语言的优化](https://www.jianshu.com/p/d941172f321c)