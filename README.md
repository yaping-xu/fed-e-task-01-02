# 简答题
## 简答一、说出以下执行结果，并且解释为什么
执行结果为10，因为i的定义用var 会进行变量提升，当循环结束后，i的值为10，所以a[6]()执行结果为10
## 简答二、请说出最终执行结果，并解释为什么
执行结果为 tmp is not defined, 因为if代码块中的tmp是在console后面定义的，所以先console，会报错
## 简答三、结合Es6找到数组中最小值
Math.min(...arr)
## 简答四、详细说var、let、const三种声明变量方式的差异
- var声明的变量会被挂载到全局Global，存在变量提升，并且在函数体执行完成并不存在引用的时候最后被回收释放
- const 块级作用域，只能在块级的内部进行访问，被挂载在scope中，const通常去声明常量，const声明对象后，不能去更改对象的引用地址
- let 块级作用域，只能在块级的内部进行访问，被挂载在scope中，let通常去声明变量，声明对象后，可以去改变对象的引用地址
## 简答五、说出代码执行结果，并解释为什么
执行结果为20，因为fn内部的箭头函数指向的是当前调用,所以函数体内部的this指向obj对象，this.name就位obj里面的内部，20
## 简答六、简述Symbol对象的用途
Symbol是一种全新的原始数据类型，在es2015之前，对象的键值都是字符串，全局的对象添加属性容易出现命名冲突
- Symbol的特点是独一无二，通过Symbol(创建的每个值都是独一无二的，所以我们可以将Symbol作为对象的属性值
- 因为使用传统的for...in 是拿不到Symbol定义的属性值，所以可以借助此特性模拟对象的私有成员，如需获取可以通过Object.getOwnProperty(obj)获取全是Symbol的属性名对象
## 简答七、谈谈深拷贝和浅拷贝
- js中基本数据类型存放在栈中，而引用数据类型存放在堆中，变量时间上是一个存放在栈内存中的地址，这个指针指向堆内存中的地址
- 浅拷贝只是拷贝了变量，并没有改变他的内存地址，重新赋值会改变源对象
- 深拷贝是拷贝了地址和内存，重新赋值不会改变源对象
## 简答八、简述TypeScript 和 JavaScript之间的关系
- Typescript和JavaScript是两种脚本语言
- TypeScript是基于JavaScript之上的编程语言，重点解决了js类型系统里面的不足，大大提高了代码的可靠程度

## 简答九、TypeScript的优缺点
- 优点：ts是强类型的语言，所以在编写的过程中，可以将错误更早的暴露，类型系统也可以减少代码层面不必要的判断
- 缺点：适用于长期维护且工程较大的项目，对于工程较小的项目，在项目初期可能会浪费很多精力

## 简答十、描述引用计数的工作原理和有缺点
- 核心思想：就是设置引用数，判断当前的引用数是否为0
- 算法规则：当某个对象引用关系发生改变的时候，引用计数器就会去修改这个对象的对应的引用数值，引用数值为0时立即回收
- 缺点：无法回收循环对象

## 简答十一、描述标记整理算法的工作流程
- 相当于标记清除的增强，主要分为两个阶段，标记阶段和整理清除阶段
- 标记阶段：遍历所有对象找到并标记可达对象
- 整理清除阶段：遍历所有对象 先执行整理，移动对象位置，然后清除没有被标记的对象，接着会把第一阶段的标记抹掉

## 简答十二、描述V8中新生代存储区垃圾回收的流程
- 新生代的回收算法主要用到的复制算法 + 标记算法，将存储新生代对象的空间分成同等大小的两个空间，使用空间叫做From, 空闲空间叫做To
- 所有的活动对象都放在From里面
- 当From存储到一定量的时候，触发GC操作
- 标记整理后，把标记的活动对象复制到To空间
- 然后再把To复制到From，达到空间置换

## 简答十三、描述增量标记算法在何时使用及工作原理
- 老生代对象回收过程中，当空间不足的时候会触发标记整理，之后程序执行后 触发增量标记算法
- 主要工作原理：
  碎片化的回收机制，程序执行过程中，中断的回收，然后程序会继续执行，然后再进行回收，直到垃圾完成清除

# 学习笔记
## [ECMAScript](https://www.jianshu.com/p/44376bfc8208)
## [TypeScript语言](https://www.jianshu.com/p/c54c9b223a7c)
## [JS性能优化——JavaScript语言的优化](https://www.jianshu.com/p/d941172f321c)